#include "sbox.h"
#include <iostream>
using namespace std;

//Inicializar variables est√°ticas
//S1_8
vector<Vector> Sbox::initS1_8() {
	vector<Vector> S_aux;
	S_aux.resize(8);

	int S_1[] = {0x0e, 0x04, 0x0d, 0x01, 0x02, 0x0f, 0x0b, 0x08, 0x03, 0x0a, 0x06, 0x0c, 0x05, 0x09, 0x00, 0x07,
	        0x00, 0x0f, 0x07, 0x04, 0x0e, 0x02, 0x0d, 0x01, 0x0a, 0x06, 0x0c, 0x0b, 0x09, 0x05, 0x03, 0x08,
	        0x04, 0x01, 0x0e, 0x08, 0x0d, 0x06, 0x02, 0x0b, 0x0f, 0x0c, 0x09, 0x07, 0x03, 0x0a, 0x05, 0x00,
	        0x0f, 0x0c, 0x08, 0x02, 0x04, 0x09, 0x01, 0x07, 0x05, 0x0b, 0x03, 0x0e, 0x0a, 0x00, 0x06, 0x0d};
	Vector aux1(S_1,S_1 + sizeof(S_1) / sizeof(long));
	S_aux[0] = aux1;
	int S_2[] = {0x0f, 0x01, 0x08, 0x0e, 0x06, 0x0b, 0x03, 0x04, 0x09, 0x07, 0x02, 0x0d, 0x0c, 0x00, 0x05, 0x0a,
	        0x03, 0x0d, 0x04, 0x07, 0x0f, 0x02, 0x08, 0x0e, 0x0c, 0x00, 0x01, 0x0a, 0x06, 0x09, 0x0b, 0x05,
	        0x00, 0x0e, 0x07, 0x0b, 0x0a, 0x04, 0x0d, 0x01, 0x05, 0x08, 0x0c, 0x06, 0x09, 0x03, 0x02, 0x0f,
	        0x0d, 0x08, 0x0a, 0x01, 0x03, 0x0f, 0x04, 0x02, 0x0b, 0x06, 0x07, 0x0c, 0x00, 0x05, 0x0e, 0x09};
	Vector aux2(S_2,S_2 + sizeof(S_2) / sizeof(long));
	S_aux[1] = aux2;
	int S_3[] = {0x0a, 0x00, 0x09, 0x0e, 0x06, 0x03, 0x0f, 0x05, 0x01, 0x0d, 0x0c, 0x07, 0x0b, 0x04, 0x02, 0x08,
	        0x0d, 0x07, 0x00, 0x09, 0x03, 0x04, 0x06, 0x0a, 0x02, 0x08, 0x05, 0x0e, 0x0c, 0x0b, 0x0f, 0x01,
	        0x0d, 0x06, 0x04, 0x09, 0x08, 0x0f, 0x03, 0x00, 0x0b, 0x01, 0x02, 0x0c, 0x05, 0x0a, 0x0e, 0x07,
	        0x01, 0x0a, 0x0d, 0x00, 0x06, 0x09, 0x08, 0x07, 0x04, 0x0f, 0x0e, 0x03, 0x0b, 0x05, 0x02, 0x0c};
	Vector aux3(S_3,S_3 + sizeof(S_3) / sizeof(long));
	S_aux[2] = aux3;
	int S_4[] = {0x07, 0x0d, 0x0e, 0x03, 0x00, 0x06, 0x09, 0x0a, 0x01, 0x02, 0x08, 0x05, 0x0b, 0x0c, 0x04, 0x0f,
	        0x0d, 0x08, 0x0b, 0x05, 0x06, 0x0f, 0x00, 0x03, 0x04, 0x07, 0x02, 0x0c, 0x01, 0x0a, 0x0e, 0x09,
	        0x0a, 0x06, 0x09, 0x00, 0x0c, 0x0b, 0x07, 0x0d, 0x0f, 0x01, 0x03, 0x0e, 0x05, 0x02, 0x08, 0x04,
	        0x03, 0x0f, 0x00, 0x06, 0x0a, 0x01, 0x0d, 0x08, 0x09, 0x04, 0x05, 0x0b, 0x0c, 0x07, 0x02, 0x0e};
	Vector aux4(S_4,S_4 + sizeof(S_4) / sizeof(long));
	S_aux[3] = aux4;
	int S_5[] = {0x02, 0x0c, 0x04, 0x01, 0x07, 0x0a, 0x0b, 0x06, 0x08, 0x05, 0x03, 0x0f, 0x0d, 0x00, 0x0e, 0x09,
	        0x0e, 0x0b, 0x02, 0x0c, 0x04, 0x07, 0x0d, 0x01, 0x05, 0x00, 0x0f, 0x0a, 0x03, 0x09, 0x08, 0x06,
	        0x04, 0x02, 0x01, 0x0b, 0x0a, 0x0d, 0x07, 0x08, 0x0f, 0x09, 0x0c, 0x05, 0x06, 0x03, 0x00, 0x0e,
	        0x0b, 0x08, 0x0c, 0x07, 0x01, 0x0e, 0x02, 0x0d, 0x06, 0x0f, 0x00, 0x09, 0x0a, 0x04, 0x05, 0x03};
	Vector aux5(S_5,S_5 + sizeof(S_5) / sizeof(long));
	S_aux[4] = aux5;
	int S_6[] = {0x0c, 0x01, 0x0a, 0x0f, 0x09, 0x02, 0x06, 0x08, 0x00, 0x0d, 0x03, 0x04, 0x0e, 0x07, 0x05, 0x0b,
	        0x0a, 0x0f, 0x04, 0x02, 0x07, 0x0c, 0x09, 0x05, 0x06, 0x01, 0x0d, 0x0e, 0x00, 0x0b, 0x03, 0x08,
	        0x09, 0x0e, 0x0f, 0x05, 0x02, 0x08, 0x0c, 0x03, 0x07, 0x00, 0x04, 0x0a, 0x01, 0x0d, 0x0b, 0x06,
	        0x04, 0x03, 0x02, 0x0c, 0x09, 0x05, 0x0f, 0x0a, 0x0b, 0x0e, 0x01, 0x07, 0x06, 0x00, 0x08, 0x0d};
	Vector aux6(S_6,S_6 + sizeof(S_6) / sizeof(long));
	S_aux[5] = aux6;
	int S_7[] = {0x04, 0x0b, 0x02, 0x0e, 0x0f, 0x00, 0x08, 0x0d, 0x03, 0x0c, 0x09, 0x07, 0x05, 0x0a, 0x06, 0x01,
	        0x0d, 0x00, 0x0b, 0x07, 0x04, 0x09, 0x01, 0x0a, 0x0e, 0x03, 0x05, 0x0c, 0x02, 0x0f, 0x08, 0x06,
	        0x01, 0x04, 0x0b, 0x0d, 0x0c, 0x03, 0x07, 0x0e, 0x0a, 0x0f, 0x06, 0x08, 0x00, 0x05, 0x09, 0x02,
	        0x06, 0x0b, 0x0d, 0x08, 0x01, 0x04, 0x0a, 0x07, 0x09, 0x05, 0x00, 0x0f, 0x0e, 0x02, 0x03, 0x0c};
	Vector aux7(S_7,S_7 + sizeof(S_7) / sizeof(long));
	S_aux[6] = aux7;
	int S_8[] = {0x0d, 0x02, 0x08, 0x04, 0x06, 0x0f, 0x0b, 0x01, 0x0a, 0x09, 0x03, 0x0e, 0x05, 0x00, 0x0c, 0x07,
	        0x01, 0x0f, 0x0d, 0x08, 0x0a, 0x03, 0x07, 0x04, 0x0c, 0x05, 0x06, 0x0b, 0x00, 0x0e, 0x09, 0x02,
	        0x07, 0x0b, 0x04, 0x01, 0x09, 0x0c, 0x0e, 0x02, 0x00, 0x06, 0x0a, 0x0d, 0x0f, 0x03, 0x05, 0x08,
	        0x02, 0x01, 0x0e, 0x07, 0x04, 0x0a, 0x08, 0x0d, 0x0f, 0x0c, 0x09, 0x00, 0x03, 0x05, 0x06, 0x0b};
	Vector aux8(S_8,S_8 + sizeof(S_8) / sizeof(long));
	S_aux[7] = aux8;
	return S_aux;
}

Vector Sbox::initExtension() {
	int Ext[] = {0x20, 0x01, 0x02, 0x03, 0x04, 0x05,
		       0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
		       0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d,
		       0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11,
		       0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
		       0x14, 0x15, 0x16, 0x17, 0x18, 0x19,
		       0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d,
		       0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x01};
	Vector aux(Ext,Ext + sizeof(Ext) / sizeof(long));
	return aux;
}

Vector Sbox::initFperm() {
	int Fperm[] = {0x10, 0x07, 0x14, 0x15,
		       0x1d, 0x0c, 0x1c, 0x11,
		       0x01, 0x0f, 0x17, 0x1a,
		       0x05, 0x12, 0x1f, 0x0a,
		       0x02, 0x08, 0x18, 0x0e,
		       0x20, 0x1b, 0x03, 0x09,
		       0x13, 0x0d, 0x1e, 0x06,
		       0x16, 0x0b, 0x04, 0x19};
	Vector aux(Fperm,Fperm + sizeof(Fperm) / sizeof(long));
	return aux;
}

vector<Vector> Sbox::S1_8 = Sbox::initS1_8();
Vector Sbox::Extension = Sbox::initExtension();
Vector Sbox::Fperm = Sbox::initFperm();

Sbox::Sbox() {
}

Sbox::~Sbox() {
}

Bitset Sbox::run(const Bitset reg, const Bitset key, char MODE) {
	//Se tiene un array de bitsets con cada subconjunto de 6 bits
	_reg = reg;
	_key = key;
	vector<Bitset> subsets;
	Vector row,column;
	Bitset expandido = Expand();
	if (MODE == EXTENDED) cout << "\n\t***************************\n\n";
	if (MODE == EXTENDED) cout << "Registro: " << _reg << endl;
	if (MODE == EXTENDED) cout << "\nRegistro expandido:\t" << expandido << endl;
	if (MODE == EXTENDED) cout << "Clave inicial:\t\t" << _key << endl;
	expandido = expandido ^ _key;
	if (MODE == EXTENDED) cout << "Registro XOR Clave:\t" << expandido << "\n\n";
	//Cajas S
	for (int i(0),pos(0); i < 8; i++, pos+=6) {
		//Obtener un subconjunto de 6 bits
		Bitset subset = expandido.subset(pos,6);
		subsets.push_back(subset);
		//Obtener valor de la fila y la columna del subconjunto obtenido
		row.push_back(s2i(subset.subset(5,1).to_s() + subset.subset(0,1).to_s()));
		column.push_back(subset.subset(1,4).to_ul());
	}
	//Obtener el vector de bitsets de 4 bits tras el paso por cajas S
	string result_s = "";
	for (int i = 7; i >= 0; i--) {
		int val = S1_8[7-i][row[i]*16 + column[i]];
		if (MODE == EXTENDED) cout << subsets[i] << " -> Caja_S"<< 7-i << "[" << row[i] << "," << column[i] << "]:" << val << endl;
		//Se van guardando los valores en una cadena para luego crear el bitset
		result_s.append(padZeros(int2bin(val),4));
	}
	Bitset v4bits(result_s);
	//Realizar permutacion final y devolver resultado
	if (MODE == EXTENDED) cout << "\n\t***************************\n\n";
	return Fpermf(v4bits);
}

Bitset Sbox::getKey() const {
	return _key;
}

Bitset Sbox::getReg() const {
	return _reg;
}

int Sbox::s2i(string bin) {
	return bitset<2>(bin).to_ulong();
}

Bitset Sbox::Expand() {
	Bitset expansion(0,48);
	//cout << expansion.size() << endl;
	for (int i = 0; i < 48; i++) {
		expansion[48-i-1] = _reg[32 - (Extension[i] - 1) - 1];
	}
	/*for (int i = 0; i < 48; i++) {
		expansion[i] = _reg[Extension[i]-1];
	}*/
	return expansion;
}

string padZeros(const string str, const int length) {
	if (str.length() == length)
		return str;
	else {
		string res = str;
		for (int i = 0; i < (length - str.length()); i++)
			res = "0" + res;
		return res;
	}
}

Bitset Sbox::Fpermf(Bitset bin) {
	Bitset result(0,32);
	for (int i = 0; i < 32; i++)
		result[32-i-1] = bin[32 -(Fperm[i] - 1)-1];
	return result;
}

